"""
Monitoring orchestrator that coordinates all monitoring components.
Manages performance monitoring, health checks, notifications, and dashboard updates.
"""

import asyncio
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import json
from dataclasses import asdict

from src.monitoring.performance_monitor import performance_monitor, PerformanceMetrics, SystemHealthMetrics
from src.monitoring.notifications import notification_manager, NotificationType, Priority
from src.monitoring.dashboard import dashboard_aggregator
from src.monitoring.health_checks import health_checker, HealthStatus
from config.settings import settings

logger = logging.getLogger(__name__)


class MonitoringOrchestrator:
    """
    Central orchestrator for all monitoring activities.
    """
    
    def __init__(self):
        self.is_running = False
        self.start_time: Optional[datetime] = None
        
        # Monitoring intervals (seconds)
        self.performance_interval = 300      # 5 minutes
        self.health_check_interval = 600     # 10 minutes
        self.dashboard_update_interval = 60  # 1 minute
        self.daily_report_time = "09:00"     # Daily report time (UTC)
        self.weekly_report_day = 0           # Monday (0 = Monday, 6 = Sunday)
        
        # Last report times
        self.last_daily_report = None
        self.last_weekly_report = None
        
        # Performance tracking
        self.performance_history = []
        self.alert_counters = {
            'performance_alerts': 0,
            'risk_alerts': 0,
            'system_alerts': 0,
            'trade_notifications': 0
        }
    
    async def initialize(self):
        """Initialize all monitoring components."""
        try:
            logger.info("Initializing monitoring orchestrator")
            
            # Initialize individual components
            await performance_monitor.initialize()
            await notification_manager.initialize()
            await dashboard_aggregator.initialize()
            
            # Send startup notification
            await notification_manager.send_startup_notification()
            
            logger.info("Monitoring orchestrator initialized successfully")
            
        except Exception as e:
            logger.error(f"Failed to initialize monitoring orchestrator: {e}")
            raise
    
    async def start(self):
        """Start all monitoring activities."""
        if self.is_running:
            logger.warning("Monitoring orchestrator already running")
            return
        
        try:
            self.is_running = True
            self.start_time = datetime.utcnow()
            
            logger.info("Starting monitoring orchestrator")
            
            # Start all monitoring tasks
            tasks = [
                self._performance_monitoring_task(),
                self._health_monitoring_task(),
                self._dashboard_update_task(),
                self._notification_management_task(),
                self._scheduled_reports_task(),
                self._alert_management_task()
            ]
            
            await asyncio.gather(*tasks, return_exceptions=True)\n            \n        except Exception as e:\n            logger.error(f\"Error in monitoring orchestrator: {e}\")\n        finally:\n            self.is_running = False\n    \n    async def stop(self):\n        \"\"\"Stop all monitoring activities.\"\"\"\n        logger.info(\"Stopping monitoring orchestrator\")\n        \n        try:\n            self.is_running = False\n            \n            # Stop individual components\n            await performance_monitor.stop_monitoring()\n            await dashboard_aggregator.stop_streaming()\n            await health_checker.stop_monitoring()\n            \n            # Send shutdown notification\n            await notification_manager.send_shutdown_notification()\n            \n            logger.info(\"Monitoring orchestrator stopped successfully\")\n            \n        except Exception as e:\n            logger.error(f\"Error stopping monitoring orchestrator: {e}\")\n    \n    async def get_monitoring_status(self) -> Dict[str, Any]:\n        \"\"\"Get current monitoring system status.\"\"\"\n        try:\n            uptime = (datetime.utcnow() - self.start_time).total_seconds() / 3600 if self.start_time else 0\n            \n            # Get component statuses\n            performance_status = performance_monitor.monitoring_active\n            dashboard_status = dashboard_aggregator.is_running\n            health_status = health_checker.monitoring_active\n            \n            # Get recent health check results\n            overall_health = await health_checker.get_overall_health()\n            \n            return {\n                'orchestrator': {\n                    'running': self.is_running,\n                    'uptime_hours': uptime,\n                    'start_time': self.start_time.isoformat() if self.start_time else None\n                },\n                'components': {\n                    'performance_monitor': performance_status,\n                    'dashboard_aggregator': dashboard_status,\n                    'health_checker': health_status,\n                    'notification_manager': True  # Always considered active if initialized\n                },\n                'overall_health': {\n                    'status': overall_health.status.value,\n                    'message': overall_health.message,\n                    'details': overall_health.details\n                },\n                'alert_counters': self.alert_counters,\n                'last_reports': {\n                    'daily': self.last_daily_report.isoformat() if self.last_daily_report else None,\n                    'weekly': self.last_weekly_report.isoformat() if self.last_weekly_report else None\n                }\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error getting monitoring status: {e}\")\n            return {'error': str(e)}\n    \n    async def trigger_health_check(self) -> Dict[str, Any]:\n        \"\"\"Manually trigger a comprehensive health check.\"\"\"\n        try:\n            logger.info(\"Triggering manual health check\")\n            \n            results = await health_checker.run_all_checks()\n            overall_health = await health_checker.get_overall_health()\n            \n            # Send notifications for critical issues\n            critical_issues = [r for r in results.values() if r.status == HealthStatus.CRITICAL]\n            if critical_issues:\n                for issue in critical_issues:\n                    await notification_manager.send_system_alert(\n                        component=issue.component,\n                        status=\"CRITICAL\",\n                        message=issue.message\n                    )\n                    self.alert_counters['system_alerts'] += 1\n            \n            return {\n                'overall_health': asdict(overall_health),\n                'component_results': {k: asdict(v) for k, v in results.items()},\n                'critical_issues': len(critical_issues),\n                'timestamp': datetime.utcnow().isoformat()\n            }\n            \n        except Exception as e:\n            logger.error(f\"Error triggering health check: {e}\")\n            return {'error': str(e)}\n    \n    async def generate_performance_report(self, period_days: int = 7) -> Dict[str, Any]:\n        \"\"\"Generate a comprehensive performance report.\"\"\"\n        try:\n            logger.info(f\"Generating performance report for {period_days} days\")\n            \n            # Get performance report from performance monitor\n            performance_report = await performance_monitor.generate_performance_report(period_days)\n            \n            # Get dashboard snapshot for current state\n            dashboard_snapshot = await dashboard_aggregator.generate_snapshot()\n            \n            # Get trading heatmap\n            trading_heatmap = await dashboard_aggregator.get_trading_heatmap(period_days)\n            \n            # Compile comprehensive report\n            report = {\n                'report_info': {\n                    'generated_at': datetime.utcnow().isoformat(),\n                    'period_days': period_days,\n                    'report_type': 'comprehensive_performance'\n                },\n                'performance_metrics': performance_report,\n                'current_portfolio': dashboard_snapshot.portfolio,\n                'trading_activity': trading_heatmap,\n                'system_health': asdict(await health_checker.get_overall_health()),\n                'alert_summary': self.alert_counters.copy()\n            }\n            \n            return report\n            \n        except Exception as e:\n            logger.error(f\"Error generating performance report: {e}\")\n            return {'error': str(e)}\n    \n    async def _performance_monitoring_task(self):\n        \"\"\"Background task for performance monitoring.\"\"\"\n        while self.is_running:\n            try:\n                # Start performance monitoring if not already running\n                if not performance_monitor.monitoring_active:\n                    asyncio.create_task(performance_monitor.start_monitoring())\n                \n                # Get current performance metrics\n                metrics = await performance_monitor.get_current_performance()\n                self.performance_history.append(metrics)\n                \n                # Keep only last 100 performance snapshots\n                if len(self.performance_history) > 100:\n                    self.performance_history = self.performance_history[-100:]\n                \n                # Check for performance alerts\n                await self._check_performance_alerts(metrics)\n                \n                await asyncio.sleep(self.performance_interval)\n                \n            except Exception as e:\n                logger.error(f\"Error in performance monitoring task: {e}\")\n                await asyncio.sleep(60)\n    \n    async def _health_monitoring_task(self):\n        \"\"\"Background task for health monitoring.\"\"\"\n        while self.is_running:\n            try:\n                # Run health checks\n                results = await health_checker.run_all_checks()\n                \n                # Check for critical health issues\n                critical_issues = [r for r in results.values() if r.status == HealthStatus.CRITICAL]\n                warning_issues = [r for r in results.values() if r.status == HealthStatus.WARNING]\n                \n                # Send notifications for critical issues\n                for issue in critical_issues:\n                    await notification_manager.send_system_alert(\n                        component=issue.component,\n                        status=\"CRITICAL\",\n                        message=issue.message\n                    )\n                    self.alert_counters['system_alerts'] += 1\n                \n                # Log health status\n                if critical_issues:\n                    logger.error(f\"Critical health issues detected: {len(critical_issues)}\")\n                elif warning_issues:\n                    logger.warning(f\"Health warnings detected: {len(warning_issues)}\")\n                else:\n                    logger.debug(\"All health checks passed\")\n                \n                await asyncio.sleep(self.health_check_interval)\n                \n            except Exception as e:\n                logger.error(f\"Error in health monitoring task: {e}\")\n                await asyncio.sleep(120)\n    \n    async def _dashboard_update_task(self):\n        \"\"\"Background task for dashboard updates.\"\"\"\n        while self.is_running:\n            try:\n                # Start dashboard streaming if not already running\n                if not dashboard_aggregator.is_running:\n                    asyncio.create_task(dashboard_aggregator.start_streaming())\n                \n                await asyncio.sleep(self.dashboard_update_interval)\n                \n            except Exception as e:\n                logger.error(f\"Error in dashboard update task: {e}\")\n                await asyncio.sleep(60)\n    \n    async def _notification_management_task(self):\n        \"\"\"Background task for notification management.\"\"\"\n        while self.is_running:\n            try:\n                # Clean up old notifications periodically\n                notification_manager.cleanup_old_notifications()\n                \n                await asyncio.sleep(3600)  # Every hour\n                \n            except Exception as e:\n                logger.error(f\"Error in notification management task: {e}\")\n                await asyncio.sleep(300)\n    \n    async def _scheduled_reports_task(self):\n        \"\"\"Background task for scheduled reports.\"\"\"\n        while self.is_running:\n            try:\n                now = datetime.utcnow()\n                \n                # Check for daily report\n                if self._should_send_daily_report(now):\n                    await self._send_daily_report()\n                    self.last_daily_report = now\n                \n                # Check for weekly report\n                if self._should_send_weekly_report(now):\n                    await self._send_weekly_report()\n                    self.last_weekly_report = now\n                \n                await asyncio.sleep(300)  # Check every 5 minutes\n                \n            except Exception as e:\n                logger.error(f\"Error in scheduled reports task: {e}\")\n                await asyncio.sleep(600)\n    \n    async def _alert_management_task(self):\n        \"\"\"Background task for alert management and escalation.\"\"\"\n        while self.is_running:\n            try:\n                # Check for alert patterns that might need escalation\n                await self._check_alert_escalation()\n                \n                await asyncio.sleep(900)  # Every 15 minutes\n                \n            except Exception as e:\n                logger.error(f\"Error in alert management task: {e}\")\n                await asyncio.sleep(300)\n    \n    async def _check_performance_alerts(self, metrics: PerformanceMetrics):\n        \"\"\"Check performance metrics for alert conditions.\"\"\"\n        try:\n            # Drawdown alert\n            if metrics.current_drawdown > 0.15:  # 15% drawdown\n                await notification_manager.send_performance_alert(\n                    alert_type=\"High Drawdown\",\n                    current_value=metrics.current_drawdown,\n                    threshold=0.15,\n                    message=f\"Portfolio drawdown is {metrics.current_drawdown:.2%}\"\n                )\n                self.alert_counters['performance_alerts'] += 1\n            \n            # Low Sharpe ratio alert\n            if metrics.sharpe_ratio < 0.5 and len(self.performance_history) > 20:\n                await notification_manager.send_performance_alert(\n                    alert_type=\"Low Sharpe Ratio\",\n                    current_value=metrics.sharpe_ratio,\n                    threshold=1.0,\n                    message=f\"Sharpe ratio is below target: {metrics.sharpe_ratio:.2f}\"\n                )\n                self.alert_counters['performance_alerts'] += 1\n            \n            # High volatility alert\n            if metrics.volatility > 0.5:  # 50% annualized volatility\n                await notification_manager.send_risk_alert(\n                    risk_type=\"High Volatility\",\n                    symbol=\"PORTFOLIO\",\n                    current_value=metrics.volatility,\n                    threshold=0.3,\n                    message=f\"Portfolio volatility is high: {metrics.volatility:.2%}\"\n                )\n                self.alert_counters['risk_alerts'] += 1\n            \n        except Exception as e:\n            logger.error(f\"Error checking performance alerts: {e}\")\n    \n    def _should_send_daily_report(self, now: datetime) -> bool:\n        \"\"\"Check if daily report should be sent.\"\"\"\n        if self.last_daily_report is None:\n            return True\n        \n        # Check if it's past the daily report time and we haven't sent today\n        report_time = now.replace(hour=int(self.daily_report_time.split(':')[0]),\n                                 minute=int(self.daily_report_time.split(':')[1]),\n                                 second=0, microsecond=0)\n        \n        return (now >= report_time and \n                self.last_daily_report.date() < now.date())\n    \n    def _should_send_weekly_report(self, now: datetime) -> bool:\n        \"\"\"Check if weekly report should be sent.\"\"\"\n        if self.last_weekly_report is None:\n            return now.weekday() == self.weekly_report_day\n        \n        # Check if it's the right day and we haven't sent this week\n        days_since_last = (now - self.last_weekly_report).days\n        return (now.weekday() == self.weekly_report_day and \n                days_since_last >= 7)\n    \n    async def _send_daily_report(self):\n        \"\"\"Send daily performance summary.\"\"\"\n        try:\n            logger.info(\"Sending daily performance report\")\n            \n            # Get current metrics\n            metrics = await performance_monitor.get_current_performance()\n            \n            # Get top performing symbol (simplified)\n            top_performer = \"N/A\"  # Would need actual calculation\n            \n            await notification_manager.send_daily_summary(\n                portfolio_value=metrics.total_value,\n                daily_pnl=metrics.total_pnl,\n                total_trades=metrics.total_trades,\n                win_rate=metrics.win_rate,\n                top_performer=top_performer\n            )\n            \n        except Exception as e:\n            logger.error(f\"Error sending daily report: {e}\")\n    \n    async def _send_weekly_report(self):\n        \"\"\"Send weekly performance report.\"\"\"\n        try:\n            logger.info(\"Sending weekly performance report\")\n            \n            # Generate comprehensive report\n            report_data = await self.generate_performance_report(period_days=7)\n            \n            await notification_manager.send_weekly_report(report_data)\n            \n        except Exception as e:\n            logger.error(f\"Error sending weekly report: {e}\")\n    \n    async def _check_alert_escalation(self):\n        \"\"\"Check if alerts need escalation.\"\"\"\n        try:\n            # Check for excessive alerts\n            total_alerts = sum(self.alert_counters.values())\n            \n            if total_alerts > 50:  # More than 50 alerts\n                await notification_manager.send_system_alert(\n                    component=\"monitoring\",\n                    status=\"WARNING\",\n                    message=f\"High alert volume detected: {total_alerts} alerts\"\n                )\n                \n                # Reset counters after escalation\n                self.alert_counters = {key: 0 for key in self.alert_counters}\n            \n        except Exception as e:\n            logger.error(f\"Error checking alert escalation: {e}\")\n\n\n# Global monitoring orchestrator instance\nmonitoring_orchestrator = MonitoringOrchestrator()"
